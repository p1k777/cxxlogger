# Основная идея

Первоначальная цель - удобно расширяемый логгер. В процессе разработки внезапно все пошло не по плану и пришлось (надеюсь временно) оставить недоделанную работу (описание ошибок будет ниже). Обязанность за исправление уже написанного на себя пока не беру, хотя вроде допилить там не так много.

# Принцип работы

За основу взят механизм **ADL** (при передаче в функцию параметра из некоторого неймспейса в процессе выбора перегрузки функции компилятор просматривает и этот неймспейс), то есть ожидается, что пользователь определит собственный тип, после чего "научит" логгер его выводить. В этом случае есть 2 пути:

1. Перегрузить `<<`
2. Создать в нужном неймспейсе функцию `LogType` (сигнатуру см. в комментарии в `logger.hpp` и в примере)

Первый пример логичнее, если нет желания разделять просто вывод в поток и полноценное логирование, второй хорош если хочется наоборот научить и логировать по-настоящему, и просто выводить в поток.

Сначала либа пытается вызвать `LogType`, в случае неудачи пробует вывести через `<<`, в случае второй неудачи будет CE, то есть отследить ошибку будет несложно.

Ну и совсем бесполезные детали реализации (их очень легко увидеть в исходном коде):

- Вызов всех публичных методов `BaseLogger` (и наследников) влечет за собой вызов `BaseLogger::Custom`, потому что все остальные это буквально он же, только менее общий
- `BaseLogger::Custom` работает через `BaseLogger::LogMessage`, который и пытается выбрать между `<<` и `LogType`

# Известные проблемы

Все становится плохо, когда нужно как-то перегрузить вывод для `std`-типов и стандартных типов: для первой группы не получится определить перегрузку в `std` (это UB), а для вторых просто негде перегружать `LogType` (нет ассоциированных неймспейсов).

Теперь почему это все-таки не совсем ломает первоначальную цель. Для пользовательских типов (в т.ч. глобальных) все хорошо работает, для типов из `std`, для которых не определен оператор `<<` его можно определить, то есть в целом логирование возможно для любых типов, ломается только разделение на "глубокое" и "простое" (назвал их так я, но смысл, я думаю, понятен) логирование, притом варианты для фиксов уже существуеют, их просто нужно написать.
